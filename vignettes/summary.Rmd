---
title: "Summary"
author: "Karly Jerman & Ben Stenhaug"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{"Summary""}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction to combineR

The combineR package will help one look at the overlap between multiple data frames and the implications of doing different types of joins. It will help one see the missingness created from joining multiple data frames and attain summary statistics about the joining process. This includes the number of unique values in a column, percentage and counts of a joining key that are in other data frames, the amount of joining rows that are dropped from each data frame, visualizations about missing data, and more. 

However, the package will most easily be explained through an example adopted from education. Imagine a school has three datasets: one is state demographics data, one is math data, and one is ell data (English language learners data). Each of these contains many different variables. You are interested in modeling the relationship between variables in all three datasets. However, the datasets each contain different students who are identified by a student number. Before you can proceed, it would first be valuable to gather information about the relationships between the dataframes. This is where combineR is helpful. Our package, combineR, will allow a user to quickly gather insights, visualize them in an easily understandable way, and actually determine the cause of the NA values when joining data frames. 

The package is aimed at analysts in different fields who wish to join together multiple data sets and understand the relationships of the data sets. It can be used across industries and is particularly helpful for multiple data sets where all entries may not be from the same joining keys.

## Deviations from the proposal

We had originally planned on both a) providing descriptions of missingness and b) providing functionality for joining dataframes. However, we found that once the user was able to see the descriptions of missingness, it was just as easy for them to use the join functionality from dplyr as opposed to us "re-inventing the wheel" so to speak. In place of this, we created more visualization that allows a user to see where missingness occurs in either a single dataframe or many dataframes all at once.

## Contributions

The package was motivated by frustrations Ben had been having in analyzing multiple datasets as part of his research. Together, we talked through the key issues and how we can design a package to alleviate those challenges. From there, we specified the scope of the individual functions and their functionality together. Karly did an initial attempt at many of the functions. Stenhaug expanded the functionality, cleaned up bugs, and wrote a few other functions -- including helper functions. Karly added graphing functionality for nice visualizations. Ben used testthat to write tests and drafted an intial vignette. Karly took care of debugging errors and warnings in the package build process and cleaning up the documentation. There was an equitable share of work in the project.

# Summary of combineR in a Use Case

```{r}
library(combineR)
```

Imagine you are an education researcher wanting to see how ELL students perform on their exam. You have three datasets to analyze: demographics, ell, and math data. The demographics data contains all students from an area in a time frame of 3 years. Columns are student id, year, name, sex, and learning disability.

```{r}
knitr::kable(head(demographics))
```

The ell data shows ELL test. The ELL test is taken by the flagged as potentially ELL students. Columns are student id, year, and score. Students no longer take the test once they score 100.

```{r}
knitr::kable(head(ell))
```

The final included data set is math. The math data shows math test scores. Columns are student id, year, and math score. 

```{r}
knitr::kable(head(math))
```

## explain_rows

The first function we have is explain rows. It finds the number of rows, columns, and unique number of rows in your data sets. To use it, enter as many data frames as you would like and find the number of rows, the number of columns, and the number of unique rows in your data sets. We wanted to explain the rows of all three datasets available.

```{r}
explain_rows(demographics, math, ell)
```

## explain_NAs

The next function we have is explain NAs. Given one dataset, it finds the number of NA values in each column for that dataset. It outputs a sentence, a data frame, and two plots. Here, we wished to see the NA values in the math dataset.

```{r, fig.width = 8}
explain_NAs(math)
```

If you only want the table, just type:

```{r}
explain_NAs(math)[[2]]
```

## count_keys

The next function we have is count keys. You give this as many data frames as you want and the key and it tells you how many unique values are in each data frame for the keys you specify. Here it is done for all three available datasets.

```{r}
count_keys(demographics, math, ell, keys = c("student_id", "year"))
```

## get_all_missing

When we do joins, there are two types of missing values that come up. The first are missing values that are hard coded. The second are missing values that are generated when we do a join. The get all missing function lets you specify all of the data frames that you are interested. You specify the keys (each data frame must have at least one of the keys in it). And then it tells you if you were to do all full_joins, in which variables you would see missing values and if they would come from being hard coded or from the join. 

This function outputs a table and two plots to visualize the information. Here, we chose to visualize the combination of all three given datasets.

```{r, fig.width = 8}
get_all_missing(demographics, math, ell, keys = c("student_id", "year"))
```

# Additional Information

For example, here are some insights that could come from this package:

There are a total of X unique students in the data
Y% of students in demographic data are in the ell data while Z% of students in the state test data are in the math data. If we want to create a completely non-missing dataset that includes gender and age from state demographics data, ell score and student id from ell data, and math score from the math data this will include XX students. YY students were dropped because they were in the demographic data but in neither of the other data sets. ZZ students were in all three data frames but had an NA in the math score variable from the math data.
